#!/bin/bash

# history+ - Professional command-line utility for logging commands and outputs
# Author: history+ contributors
# License: MIT

set -euo pipefail

readonly SCRIPT_NAME="history+"
readonly CONFIG_DIR="$HOME/.history_plus"
readonly CONFIG_FILE="$CONFIG_DIR/config"
readonly PID_FILE="$CONFIG_DIR/history_plus.pid"
readonly LOG_DIR="$CONFIG_DIR/logs"

# Professional logging configuration
readonly MAX_LOG_SIZE_MB=100  # Auto-rotate when log exceeds this size
readonly MAX_LOG_AGE_DAYS=90  # Default cleanup age
readonly JSON_LOG_DIR="$CONFIG_DIR/json_logs"  # JSON format logs

# Default excluded commands (can be overridden by config file)
readonly DEFAULT_EXCLUDES="ssh,mysql,ftp,history+"

# Hardcoded security-critical commands that should never be logged
# These cannot be overridden by user configuration
readonly SECURITY_CRITICAL_COMMANDS="passwd,su,login,ssh-keygen"

# Commands that should log the command but not capture interactive password input
readonly PASSWORD_INPUT_COMMANDS="sudo,gpg,openssl"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Print colored messages
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Show usage information
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME <command>

Commands:
  start     Start logging session [--json] [--keywords file]
  stop      Stop current logging session
  status    Show current session status
  tail      Live view of current log file [--json]
  list      List all previous logging sessions
  rotate    Rotate current log (start new session)
  cleanup   Clean up old logs (with size/age filters)
  export    Export logs to different formats
  security  Check configuration for security issues
  help      Show this help message

Examples:
  $SCRIPT_NAME start    # Begin logging commands and outputs
  $SCRIPT_NAME start --json  # Log in JSON format for parsing
  $SCRIPT_NAME stop     # End current session
  $SCRIPT_NAME status   # Check if logging is active
  $SCRIPT_NAME tail     # Watch log file in real-time
  $SCRIPT_NAME list     # Show all previous sessions
  $SCRIPT_NAME rotate   # Start new log file (auto-rotate)
  $SCRIPT_NAME cleanup --older-than 30d  # Remove logs older than 30 days
  $SCRIPT_NAME export --format json session.log  # Convert to JSON

Configuration:
  Config directory: $CONFIG_DIR
  Config file: $CONFIG_FILE
  
For more information, visit: https://github.com/your-repo/history-plus
EOF
}

# Initialize configuration directory and files
init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
        print_info "Created configuration directory: $CONFIG_DIR"
    fi
    
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
        print_info "Created log directory: $LOG_DIR"
    fi
    
    # Create default config if it doesn't exist
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "$DEFAULT_EXCLUDES" > "$CONFIG_FILE"
        print_info "Created default config file: $CONFIG_FILE"
    fi
    
    # Secure the directory
    chmod 700 "$CONFIG_DIR"
    
    # Validate configuration for security issues
    validate_security_config
}

# Validate configuration for potential security issues
validate_security_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        return 0
    fi
    
    local config_content
    config_content=$(cat "$CONFIG_FILE")
    
    # Check for critical security commands that might be missing (these are never logged)
    local critical_missing=()
    IFS=',' read -ra critical_commands <<< "$SECURITY_CRITICAL_COMMANDS"
    
    for cmd in "${critical_commands[@]}"; do
        cmd=$(echo "$cmd" | tr -d ' ')
        if [[ ! "$config_content" =~ $cmd ]]; then
            critical_missing+=("$cmd")
        fi
    done
    
    if [[ ${#critical_missing[@]} -gt 0 ]]; then
        print_warning "Security Notice: Some critical commands are not in your exclusion config:"
        printf "  Missing: %s\n" "${critical_missing[@]}"
        print_info "These commands are still protected by hardcoded security rules (never logged)."
        echo
    fi
    
    # Check for password input commands (these log command but not output)
    local password_missing=()
    IFS=',' read -ra password_commands <<< "$PASSWORD_INPUT_COMMANDS"
    
    for cmd in "${password_commands[@]}"; do
        cmd=$(echo "$cmd" | tr -d ' ')
        if [[ ! "$config_content" =~ $cmd ]]; then
            password_missing+=("$cmd")
        fi
    done
    
    if [[ ${#password_missing[@]} -gt 0 ]]; then
        print_info "Smart password filtering commands (command + output logged, password prompts filtered):"
        printf "  Protected: %s\n" "${password_missing[@]}"
        print_info "These commands log both command and output but filter password prompts."
        echo
    fi
}

# Get current timestamp
get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Get log filename for current session
get_log_filename() {
    local session_date
    session_date=$(date '+%Y-%m-%d_%H-%M-%S')
    echo "$LOG_DIR/history_plus_${session_date}.log"
}

# Read excluded commands from config
get_excluded_commands() {
    if [[ -f "$CONFIG_FILE" ]]; then
        tr ',' '\n' < "$CONFIG_FILE" | tr -d ' '
    else
        echo "$DEFAULT_EXCLUDES" | tr ',' '\n'
    fi
}

# Check if a command should be excluded
is_excluded_command() {
    local cmd="$1"
    local base_cmd=$(echo "$cmd" | awk '{print $1}')
    
    # Always exclude history+ itself
    if [[ "$cmd" == "history+" || "$cmd" =~ ^history\+.* ]]; then
        return 0
    fi
    
    # Check hardcoded security-critical commands (never logged at all)
    IFS=',' read -ra CRITICAL_CMDS <<< "$SECURITY_CRITICAL_COMMANDS"
    for critical_cmd in "${CRITICAL_CMDS[@]}"; do
        critical_cmd=$(echo "$critical_cmd" | tr -d ' ')
        if [[ "$base_cmd" == "$critical_cmd" ]]; then
            return 0  # Exclude completely
        fi
    done
    
    # Check commands with password flags
    if [[ "$cmd" =~ -p[[:space:]]|--password[[:space:]]|--pass[[:space:]]|--pwd[[:space:]]|--secret[[:space:]]|--token[[:space:]]|--key[[:space:]]|--auth[[:space:]] ]]; then
        return 0  # Exclude completely
    fi
    
    # Check user-configured exclusions
    local excluded_commands
    excluded_commands=$(get_excluded_commands)
    while IFS= read -r excluded; do
        if [[ -n "$excluded" && "$cmd" =~ ^$excluded ]]; then
            return 0
        fi
    done <<< "$excluded_commands"
    
    return 1  # Don't exclude
}

# Check if command should have limited output logging (command logged, but not interactive input)
is_password_input_command() {
    local cmd="$1"
    local base_cmd=$(echo "$cmd" | awk '{print $1}')
    
    IFS=',' read -ra PASSWORD_CMDS <<< "$PASSWORD_INPUT_COMMANDS"
    for password_cmd in "${PASSWORD_CMDS[@]}"; do
        password_cmd=$(echo "$password_cmd" | tr -d ' ')
        if [[ "$base_cmd" == "$password_cmd" ]]; then
            return 0  # Limited logging
        fi
    done
    
    return 1  # Normal logging
}

# Check if logging session is active
is_session_active() {
    [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null
}

# Get current log file path
get_current_log_file() {
    if is_session_active; then
        local log_file
        log_file=$(ps -p "$(cat "$PID_FILE")" -o args= | grep -o "$LOG_DIR/[^[:space:]]*" || echo "")
        if [[ -n "$log_file" && -f "$log_file" ]]; then
            echo "$log_file"
        fi
    fi
}

# Start logging session
start_session() {
    if is_session_active; then
        local current_log
        current_log=$(get_current_log_file)
        
        # Check if current log needs rotation due to size
        if [[ -n "$current_log" ]] && check_log_rotation "$current_log"; then
            print_warning "Current log file is large (>${MAX_LOG_SIZE_MB}MB)"
            print_info "Consider using '$SCRIPT_NAME rotate' to start a fresh log"
        fi
        
        print_warning "Logging session is already active (PID: $(cat "$PID_FILE"))"
        return 1
    fi
    
    init_config
    
    local log_file
    log_file=$(get_log_filename)
    
    print_info "Starting history+ logging session..."
    print_info "Log file: $log_file"
    
    # Create initial log entry
    cat >> "$log_file" << EOF
=== history+ session started at $(get_timestamp) ===
Shell: $SHELL
User: $USER
Working Directory: $PWD
PID: $$
Host: $(hostname)
===============================================

EOF

    # Set up the logging environment
    export HISTPLUS_LOG_FILE="$log_file"
    export HISTPLUS_ACTIVE=1
    
    # Create a new shell with command logging
    exec bash --rcfile <(
        cat << 'RCEOF'
# Source user's bashrc if it exists
[[ -f ~/.bashrc ]] && source ~/.bashrc

# Save original PS1
HISTPLUS_ORIGINAL_PS1="$PS1"

# Set up command logging
log_command() {
    local cmd="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Skip empty commands
    [[ -z "$cmd" || "$cmd" =~ ^[[:space:]]*$ ]] && return
    
    # Check if command should be completely excluded
    if is_excluded_command "$cmd"; then
        echo "[$timestamp]" >> "$HISTPLUS_LOG_FILE"
        echo "Command: $cmd" >> "$HISTPLUS_LOG_FILE"
        echo "Output: [EXCLUDED - SENSITIVE COMMAND]" >> "$HISTPLUS_LOG_FILE"
        echo "---" >> "$HISTPLUS_LOG_FILE"
        return
    fi
    
    # Check if this is a password input command (log command AND output, but filter password prompts)
    if is_password_input_command "$cmd"; then
        echo "[$timestamp]" >> "$HISTPLUS_LOG_FILE"
        echo "Command: $cmd" >> "$HISTPLUS_LOG_FILE"
        echo "Output:" >> "$HISTPLUS_LOG_FILE"
        
        # Execute command and filter password prompts from output
        eval "$cmd" 2>&1 | while IFS= read -r line; do
            # Filter out password prompts but keep everything else
            if [[ ! "$line" =~ (\[sudo\]\ password|Password:|Enter\ password|password\ for) ]]; then
                echo "$line" | tee -a "$HISTPLUS_LOG_FILE"
            else
                echo "[PASSWORD PROMPT FILTERED]" >> "$HISTPLUS_LOG_FILE"
            fi
        done
        
        # Capture exit code
        local exit_code=${PIPESTATUS[0]}
        if [[ $exit_code -ne 0 ]]; then
            echo "Exit Code: $exit_code" >> "$HISTPLUS_LOG_FILE"
        fi
        echo "---" >> "$HISTPLUS_LOG_FILE"
        return
    fi
    
    # Log the command and capture output (normal commands)
    echo "[$timestamp]" >> "$HISTPLUS_LOG_FILE"
    echo "Command: $cmd" >> "$HISTPLUS_LOG_FILE"
    echo "Output:" >> "$HISTPLUS_LOG_FILE"
    
    # Execute command and capture output
    if eval "$cmd" 2>&1 | tee -a "$HISTPLUS_LOG_FILE"; then
        echo "---" >> "$HISTPLUS_LOG_FILE"
    else
        echo "Exit Code: $?" >> "$HISTPLUS_LOG_FILE"
        echo "---" >> "$HISTPLUS_LOG_FILE"
    fi
}

# Trap to log commands before execution
trap_command() {
    local cmd
    cmd=$(history 1 | sed 's/^[[:space:]]*[0-9]*[[:space:]]*//')
    
    # Skip if this is the same as the last command (avoid double logging)
    [[ "$cmd" == "$HISTPLUS_LAST_CMD" ]] && return
    
    HISTPLUS_LAST_CMD="$cmd"
    log_command "$cmd"
}

# Set up command trapping
trap 'trap_command' DEBUG

# Cleanup function
cleanup_histplus() {
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "" >> "$HISTPLUS_LOG_FILE"
    echo "=== history+ session ended at $timestamp ===" >> "$HISTPLUS_LOG_FILE"
    [[ -f "$HOME/.history_plus/history_plus.pid" ]] && rm -f "$HOME/.history_plus/history_plus.pid"
    exit 0
}

# Set up cleanup traps
trap cleanup_histplus EXIT INT HUP TERM

# Save PID for session management
echo $$ > "$HOME/.history_plus/history_plus.pid"

# Set environment variable to indicate logging is active
export HISTPLUS_SESSION=1

# Don't modify the prompt - just show a startup message
echo -e "\033[32m●\033[0m history+ logging active. Type 'exit' or Ctrl+D to stop logging."
echo -e "\033[90m  Session will be logged to: $HISTPLUS_LOG_FILE\033[0m"
RCEOF
    ) -i
}

# Stop logging session
stop_session() {
    if ! is_session_active; then
        print_warning "No active logging session found"
        return 1
    fi
    
    local pid
    pid=$(cat "$PID_FILE")
    
    print_info "Stopping logging session (PID: $pid)..."
    
    # Send termination signal to the logging session
    if kill "$pid" 2>/dev/null; then
        # Wait a moment for cleanup
        sleep 1
        
        # Force remove PID file if it still exists
        [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        
        print_success "Logging session stopped successfully"
    else
        print_error "Failed to stop logging session"
        # Clean up stale PID file
        [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        return 1
    fi
}

# Show session status
show_status() {
    if is_session_active; then
        local pid log_file
        pid=$(cat "$PID_FILE")
        log_file=$(get_current_log_file)
        
        print_success "Logging session is ACTIVE"
        echo "  PID: $pid"
        echo "  Log file: ${log_file:-"Unknown"}"
        echo "  Config directory: $CONFIG_DIR"
        
        if [[ -f "$CONFIG_FILE" ]]; then
            echo "  Excluded commands: $(cat "$CONFIG_FILE")"
        fi
    else
        print_info "No active logging session"
        echo "  Use '$SCRIPT_NAME start' to begin logging"
        echo "  Config directory: $CONFIG_DIR"
    fi
}

# Tail current log file
tail_log() {
    local log_file
    log_file=$(get_current_log_file)
    
    if [[ -z "$log_file" ]]; then
        print_error "No active logging session found"
        return 1
    fi
    
    if [[ ! -f "$log_file" ]]; then
        print_error "Log file not found: $log_file"
        return 1
    fi
    
    print_info "Tailing log file: $log_file"
    print_info "Press Ctrl+C to stop"
    tail -f "$log_file"
}

# List all previous logging sessions
list_sessions() {
    if [[ ! -d "$LOG_DIR" ]]; then
        print_error "Log directory not found: $LOG_DIR"
        print_info "No logging sessions have been created yet"
        return 1
    fi
    
    print_info "Previous logging sessions:"
    echo
    
    local count=0
    for log_file in "$LOG_DIR"/history_plus_*.log; do
        [[ ! -f "$log_file" ]] && continue
        count=$((count + 1))
        
        local file_size start_time
        file_size=$(du -h "$log_file" 2>/dev/null | cut -f1 || echo "?")
        start_time=$(head -1 "$log_file" 2>/dev/null | grep "session started at" | sed 's/.*started at //' | sed 's/ ===//' || echo "unknown")
        
        echo "$count. $(basename "$log_file")"
        echo "   Started: $start_time"
        echo "   Size: $file_size"
        echo "   Path: $log_file"
        echo
    done
    
    if [[ $count -eq 0 ]]; then
        print_info "No log files found in $LOG_DIR"
        echo "Use '$SCRIPT_NAME start' to create your first session"
    else
        echo "Use '$SCRIPT_NAME tail' to view the active session log"
        echo "Use 'less <log-file-path>' to view any specific session log"
    fi
}

# Rotate current log (start new session file)
rotate_log() {
    if ! is_session_active; then
        print_warning "No active logging session to rotate"
        print_info "Use '$SCRIPT_NAME start' to begin a new session"
        return 1
    fi
    
    local current_log
    current_log=$(get_current_log_file)
    
    if [[ -z "$current_log" ]]; then
        print_error "Could not determine current log file"
        return 1
    fi
    
    print_info "Rotating log file..."
    print_info "Current log: $current_log"
    
    # Stop current session
    stop_session
    
    # Wait a moment for cleanup
    sleep 1
    
    # Start new session
    print_info "Starting new logging session..."
    start_session
}

# Check if log file needs rotation (size-based)
check_log_rotation() {
    local log_file="$1"
    [[ ! -f "$log_file" ]] && return 1
    
    # Get file size in MB
    local size_mb
    size_mb=$(du -m "$log_file" 2>/dev/null | cut -f1 || echo "0")
    
    [[ $size_mb -ge $MAX_LOG_SIZE_MB ]]
}

# Clean up old logs
cleanup_logs() {
    local days="$MAX_LOG_AGE_DAYS"
    local size_limit=""
    local dry_run=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --older-than)
                days="$2"
                # Remove 'd' suffix if present
                days="${days%d}"
                shift 2
                ;;
            --larger-than)
                size_limit="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --help)
                cat << EOF
Usage: $SCRIPT_NAME cleanup [OPTIONS]

Options:
  --older-than DAYS    Remove logs older than DAYS (default: $MAX_LOG_AGE_DAYS)
  --larger-than SIZE   Remove logs larger than SIZE (e.g., 100M, 1G)
  --dry-run           Show what would be deleted without deleting
  --help              Show this help

Examples:
  $SCRIPT_NAME cleanup --older-than 30d
  $SCRIPT_NAME cleanup --larger-than 100M --dry-run
EOF
                return 0
                ;;
            *)
                print_error "Unknown option: $1"
                return 1
                ;;
        esac
    done
    
    if [[ ! -d "$LOG_DIR" ]]; then
        print_info "No log directory found"
        return 0
    fi
    
    print_info "Cleaning up logs older than $days days..."
    
    local deleted_count=0
    local deleted_size=0
    
    # Find and process old files
    while IFS= read -r -d '' file; do
        local file_age file_size_mb action
        file_age=$(find "$file" -mtime +$days -print 2>/dev/null)
        file_size_mb=$(du -m "$file" 2>/dev/null | cut -f1 || echo "0")
        
        # Check age condition
        local should_delete=false
        if [[ -n "$file_age" ]]; then
            should_delete=true
            action="age > ${days}d"
        fi
        
        # Check size condition if specified
        if [[ -n "$size_limit" && "$should_delete" == false ]]; then
            local limit_mb
            case "$size_limit" in
                *M) limit_mb="${size_limit%M}" ;;
                *G) limit_mb=$((${size_limit%G} * 1024)) ;;
                *) limit_mb="$size_limit" ;;
            esac
            
            if [[ $file_size_mb -gt $limit_mb ]]; then
                should_delete=true
                action="size > $size_limit"
            fi
        fi
        
        if [[ "$should_delete" == true ]]; then
            if $dry_run; then
                echo "Would delete: $(basename "$file") (${file_size_mb}MB, $action)"
            else
                if rm "$file" 2>/dev/null; then
                    echo "Deleted: $(basename "$file") (${file_size_mb}MB, $action)"
                    ((deleted_count++))
                    ((deleted_size += file_size_mb))
                else
                    print_warning "Failed to delete: $file"
                fi
            fi
        fi
    done < <(find "$LOG_DIR" -name "history_plus_*.log" -type f -print0 2>/dev/null)
    
    if $dry_run; then
        print_info "Dry run completed"
    else
        if [[ $deleted_count -gt 0 ]]; then
            print_success "Cleaned up $deleted_count files (${deleted_size}MB total)"
        else
            print_info "No files met cleanup criteria"
        fi
    fi
}

# Export logs to different formats
export_logs() {
    local format="json"
    local input_file=""
    local output_file=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --help)
                cat << EOF
Usage: $SCRIPT_NAME export [OPTIONS] INPUT_FILE [OUTPUT_FILE]

Options:
  --format FORMAT     Output format: json, csv (default: json)
  --help             Show this help

Examples:
  $SCRIPT_NAME export --format json session.log
  $SCRIPT_NAME export --format csv session.log output.csv
EOF
                return 0
                ;;
            *)
                if [[ -z "$input_file" ]]; then
                    input_file="$1"
                else
                    output_file="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$input_file" ]]; then
        print_error "Input file required"
        return 1
    fi
    
    if [[ ! -f "$input_file" ]]; then
        print_error "Input file not found: $input_file"
        return 1
    fi
    
    # Default output file
    if [[ -z "$output_file" ]]; then
        output_file="${input_file%.*}.$format"
    fi
    
    case "$format" in
        json)
            export_to_json "$input_file" "$output_file"
            ;;
        csv)
            export_to_csv "$input_file" "$output_file"
            ;;
        *)
            print_error "Unsupported format: $format (supported: json, csv)"
            return 1
            ;;
    esac
}

# Export to JSON format
export_to_json() {
    local input="$1"
    local output="$2"
    
    # Check if jq is available for proper JSON escaping
    if ! command -v jq >/dev/null 2>&1; then
        print_error "jq is required for JSON export. Install with: apt install jq"
        return 1
    fi
    
    print_info "Converting $input to JSON format..."
    
    {
        echo "{"
        echo "  \"session\": {"
        echo "    \"exported_at\": \"$(date -Iseconds)\","
        echo "    \"source_file\": \"$input\","
        echo "    \"entries\": ["
        
        local first=true
        local current_timestamp=""
        local current_command=""
        local current_output=""
        local in_output=false
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^\[([0-9-]+\ [0-9:]+)\]$ ]]; then
                # New timestamp - output previous entry if exists
                if [[ -n "$current_timestamp" ]]; then
                    if $first; then
                        first=false
                    else
                        echo ","
                    fi
                    echo "      {"
                    echo "        \"timestamp\": \"$current_timestamp\","
                    echo "        \"command\": $(printf '%s' "$current_command" | jq -R .),"
                    echo "        \"output\": $(printf '%s' "$current_output" | jq -R .)"
                    echo "      }"
                fi
                current_timestamp="${BASH_REMATCH[1]}"
                current_command=""
                current_output=""
                in_output=false
            elif [[ "$line" =~ ^Command:\ (.*)$ ]]; then
                current_command="${BASH_REMATCH[1]}"
            elif [[ "$line" == "Output:" ]]; then
                in_output=true
            elif [[ "$line" == "---" ]]; then
                in_output=false
            elif $in_output; then
                current_output+="$line"$'\n'
            fi
        done < "$input"
        
        # Output final entry
        if [[ -n "$current_timestamp" ]]; then
            if ! $first; then
                echo ","
            fi
            echo "      {"
            echo "        \"timestamp\": \"$current_timestamp\","
            echo "        \"command\": $(printf '%s' "$current_command" | jq -R .),"
            echo "        \"output\": $(printf '%s' "$current_output" | jq -R .)"
            echo "      }"
        fi
        
        echo "    ]"
        echo "  }"
        echo "}"
    } > "$output"
    
    print_success "JSON export completed: $output"
}

# Export to CSV format  
export_to_csv() {
    local input="$1"
    local output="$2"
    
    print_info "Converting $input to CSV format..."
    
    {
        echo "timestamp,command,output_length,duration_seconds"
        
        local current_timestamp=""
        local current_command=""
        local current_output=""
        local in_output=false
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^\[([0-9-]+\ [0-9:]+)\]$ ]]; then
                # Output previous entry if exists
                if [[ -n "$current_timestamp" ]]; then
                    local output_len=${#current_output}
                    # Escape quotes in CSV data
                    local escaped_cmd="${current_command//\"/\"\"}"
                    echo "\"$current_timestamp\",\"$escaped_cmd\",\"$output_len\",\"0\""
                fi
                current_timestamp="${BASH_REMATCH[1]}"
                current_command=""
                current_output=""
                in_output=false
            elif [[ "$line" =~ ^Command:\ (.*)$ ]]; then
                current_command="${BASH_REMATCH[1]}"
            elif [[ "$line" == "Output:" ]]; then
                in_output=true
            elif [[ "$line" == "---" ]]; then
                in_output=false
            elif $in_output; then
                current_output+="$line"$'\n'
            fi
        done < "$input"
        
        # Output final entry
        if [[ -n "$current_timestamp" ]]; then
            local output_len=${#current_output}
            local escaped_cmd="${current_command//\"/\"\"}"
            echo "\"$current_timestamp\",\"$escaped_cmd\",\"$output_len\",\"0\""
        fi
    } > "$output"
    
    print_success "CSV export completed: $output"
}

# Security audit command
security_audit() {
    print_info "Running security audit on history+ configuration..."
    echo
    
    # Check configuration file
    if [[ -f "$CONFIG_FILE" ]]; then
        print_info "Configuration file: $CONFIG_FILE"
        echo "Current exclusions: $(cat "$CONFIG_FILE" | grep -v '^#' | tr '\n' ',' | sed 's/,$//')"
        echo
    else
        print_warning "No configuration file found"
    fi
    
    # Check hardcoded security exclusions
    print_info "Hardcoded security exclusions (never logged):"
    echo "  $SECURITY_CRITICAL_COMMANDS"
    echo
    
    # Check password input commands (logged but output excluded)
    print_info "Smart password filtering commands (command + output logged, password prompts filtered):"
    echo "  $PASSWORD_INPUT_COMMANDS"
    echo
    
    # Run validation
    validate_security_config
    
    # Check directory permissions
    local dir_perms
    dir_perms=$(stat -c "%a" "$CONFIG_DIR" 2>/dev/null || echo "unknown")
    if [[ "$dir_perms" == "700" ]]; then
        print_success "Configuration directory permissions: $dir_perms (secure)"
    else
        print_warning "Configuration directory permissions: $dir_perms (should be 700)"
        print_info "Fix with: chmod 700 $CONFIG_DIR"
    fi
    
    # Check for existing logs with potential sensitive data
    if [[ -d "$LOG_DIR" ]]; then
        local log_count
        log_count=$(find "$LOG_DIR" -name "*.log" -type f | wc -l)
        print_info "Found $log_count log files in $LOG_DIR"
        
        if [[ $log_count -gt 0 ]]; then
            echo
            print_info "Security recommendations:"
            echo "  1. Regularly clean old logs: history+ cleanup --older-than 30d"
            echo "  2. Review log permissions: ls -la $LOG_DIR"
            echo "  3. sudo commands log the command but not password input"
            echo "  4. Consider log encryption for sensitive environments"
        fi
    fi
    
    echo
    print_success "Security audit completed"
}

# Main function
main() {
    case "${1:-}" in
        start)
            start_session
            ;;
        stop)
            stop_session
            ;;
        status)
            show_status
            ;;
        tail)
            tail_log
            ;;
        list)
            list_sessions
            ;;
        rotate)
            rotate_log
            ;;
        cleanup)
            shift  # Remove 'cleanup' from arguments
            cleanup_logs "$@"
            ;;
        export)
            shift  # Remove 'export' from arguments
            export_logs "$@"
            ;;
        security)
            security_audit
            ;;
        help|--help|-h)
            show_usage
            ;;
        "")
            print_error "No command specified"
            echo
            show_usage
            exit 1
            ;;
        *)
            print_error "Unknown command: $1"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
