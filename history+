#!/bin/bash

# history+ - Professional command-line utility for logging commands and outputs
# Author: history+ contributors
# License: MIT

set -euo pipefail

readonly SCRIPT_NAME="history+"
readonly CONFIG_DIR="$HOME/.history_plus"
readonly CONFIG_FILE="$CONFIG_DIR/config"
readonly PID_FILE="$CONFIG_DIR/history_plus.pid"
readonly LOG_DIR="$CONFIG_DIR/logs"

# Default excluded commands (can be overridden by config file)
readonly DEFAULT_EXCLUDES="passwd,ssh,mysql,sudo,ftp,history+"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Print colored messages
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Show usage information
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME <command>

Commands:
  start     Start logging session
  stop      Stop current logging session
  status    Show current session status
  tail      Live view of current log file
  list      List all previous logging sessions
  help      Show this help message

Examples:
  $SCRIPT_NAME start    # Begin logging commands and outputs
  $SCRIPT_NAME stop     # End current session
  $SCRIPT_NAME status   # Check if logging is active
  $SCRIPT_NAME tail     # Watch log file in real-time
  $SCRIPT_NAME list     # Show all previous sessions

Configuration:
  Config directory: $CONFIG_DIR
  Config file: $CONFIG_FILE
  
For more information, visit: https://github.com/your-repo/history-plus
EOF
}

# Initialize configuration directory and files
init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
        print_info "Created configuration directory: $CONFIG_DIR"
    fi
    
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
        print_info "Created log directory: $LOG_DIR"
    fi
    
    # Create default config if it doesn't exist
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "$DEFAULT_EXCLUDES" > "$CONFIG_FILE"
        print_info "Created default config file: $CONFIG_FILE"
    fi
    
    # Secure the directory
    chmod 700 "$CONFIG_DIR"
}

# Get current timestamp
get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Get log filename for current session
get_log_filename() {
    local session_date
    session_date=$(date '+%Y-%m-%d_%H-%M-%S')
    echo "$LOG_DIR/history_plus_${session_date}.log"
}

# Read excluded commands from config
get_excluded_commands() {
    if [[ -f "$CONFIG_FILE" ]]; then
        tr ',' '\n' < "$CONFIG_FILE" | tr -d ' '
    else
        echo "$DEFAULT_EXCLUDES" | tr ',' '\n'
    fi
}

# Check if a command should be excluded
is_excluded_command() {
    local cmd="$1"
    local excluded_commands
    excluded_commands=$(get_excluded_commands)
    
    # Always exclude history+ itself
    if [[ "$cmd" == "history+" || "$cmd" =~ ^history\+.* ]]; then
        return 0
    fi
    
    # Check against user-defined exclusions
    while IFS= read -r excluded; do
        if [[ -n "$excluded" && "$cmd" =~ ^$excluded ]]; then
            return 0
        fi
    done <<< "$excluded_commands"
    
    return 1
}

# Check if logging session is active
is_session_active() {
    [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null
}

# Get current log file path
get_current_log_file() {
    if is_session_active; then
        local log_file
        log_file=$(ps -p "$(cat "$PID_FILE")" -o args= | grep -o "$LOG_DIR/[^[:space:]]*" || echo "")
        if [[ -n "$log_file" && -f "$log_file" ]]; then
            echo "$log_file"
        fi
    fi
}

# Start logging session
start_session() {
    if is_session_active; then
        print_warning "Logging session is already active (PID: $(cat "$PID_FILE"))"
        return 1
    fi
    
    init_config
    
    local log_file
    log_file=$(get_log_filename)
    
    print_info "Starting history+ logging session..."
    print_info "Log file: $log_file"
    
    # Create initial log entry
    cat >> "$log_file" << EOF
=== history+ session started at $(get_timestamp) ===
Shell: $SHELL
User: $USER
Working Directory: $PWD
PID: $$
Host: $(hostname)
===============================================

EOF

    # Set up the logging environment
    export HISTPLUS_LOG_FILE="$log_file"
    export HISTPLUS_ACTIVE=1
    
    # Create a new shell with command logging
    exec bash --rcfile <(
        cat << 'RCEOF'
# Source user's bashrc if it exists
[[ -f ~/.bashrc ]] && source ~/.bashrc

# Save original PS1
HISTPLUS_ORIGINAL_PS1="$PS1"

# Set up command logging
log_command() {
    local cmd="$1"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Skip empty commands
    [[ -z "$cmd" || "$cmd" =~ ^[[:space:]]*$ ]] && return
    
    # Check if command should be excluded
    local base_cmd
    base_cmd=$(echo "$cmd" | awk '{print $1}')
    
    # Simple exclusion check (this will be enhanced in the main script)
    if [[ "$base_cmd" =~ ^(passwd|ssh|mysql|sudo|ftp|history\+) ]]; then
        echo "[$timestamp]" >> "$HISTPLUS_LOG_FILE"
        echo "Command: $cmd" >> "$HISTPLUS_LOG_FILE"
        echo "Output: [EXCLUDED - SENSITIVE COMMAND]" >> "$HISTPLUS_LOG_FILE"
        echo "---" >> "$HISTPLUS_LOG_FILE"
        return
    fi
    
    # Log the command and capture output
    echo "[$timestamp]" >> "$HISTPLUS_LOG_FILE"
    echo "Command: $cmd" >> "$HISTPLUS_LOG_FILE"
    echo "Output:" >> "$HISTPLUS_LOG_FILE"
    
    # Execute command and capture output
    if eval "$cmd" 2>&1 | tee -a "$HISTPLUS_LOG_FILE"; then
        echo "---" >> "$HISTPLUS_LOG_FILE"
    else
        echo "Exit Code: $?" >> "$HISTPLUS_LOG_FILE"
        echo "---" >> "$HISTPLUS_LOG_FILE"
    fi
}

# Trap to log commands before execution
trap_command() {
    local cmd
    cmd=$(history 1 | sed 's/^[[:space:]]*[0-9]*[[:space:]]*//')
    
    # Skip if this is the same as the last command (avoid double logging)
    [[ "$cmd" == "$HISTPLUS_LAST_CMD" ]] && return
    
    HISTPLUS_LAST_CMD="$cmd"
    log_command "$cmd"
}

# Set up command trapping
trap 'trap_command' DEBUG

# Cleanup function
cleanup_histplus() {
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "" >> "$HISTPLUS_LOG_FILE"
    echo "=== history+ session ended at $timestamp ===" >> "$HISTPLUS_LOG_FILE"
    [[ -f "$HOME/.history_plus/history_plus.pid" ]] && rm -f "$HOME/.history_plus/history_plus.pid"
    exit 0
}

# Set up cleanup traps
trap cleanup_histplus EXIT INT HUP TERM

# Save PID for session management
echo $$ > "$HOME/.history_plus/history_plus.pid"

# Set environment variable to indicate logging is active
export HISTPLUS_SESSION=1

# Don't modify the prompt - just show a startup message
echo -e "\033[32m●\033[0m history+ logging active. Type 'exit' or Ctrl+D to stop logging."
echo -e "\033[90m  Session will be logged to: $HISTPLUS_LOG_FILE\033[0m"
RCEOF
    ) -i
}

# Stop logging session
stop_session() {
    if ! is_session_active; then
        print_warning "No active logging session found"
        return 1
    fi
    
    local pid
    pid=$(cat "$PID_FILE")
    
    print_info "Stopping logging session (PID: $pid)..."
    
    # Send termination signal to the logging session
    if kill "$pid" 2>/dev/null; then
        # Wait a moment for cleanup
        sleep 1
        
        # Force remove PID file if it still exists
        [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        
        print_success "Logging session stopped successfully"
    else
        print_error "Failed to stop logging session"
        # Clean up stale PID file
        [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
        return 1
    fi
}

# Show session status
show_status() {
    if is_session_active; then
        local pid log_file
        pid=$(cat "$PID_FILE")
        log_file=$(get_current_log_file)
        
        print_success "Logging session is ACTIVE"
        echo "  PID: $pid"
        echo "  Log file: ${log_file:-"Unknown"}"
        echo "  Config directory: $CONFIG_DIR"
        
        if [[ -f "$CONFIG_FILE" ]]; then
            echo "  Excluded commands: $(cat "$CONFIG_FILE")"
        fi
    else
        print_info "No active logging session"
        echo "  Use '$SCRIPT_NAME start' to begin logging"
        echo "  Config directory: $CONFIG_DIR"
    fi
}

# Tail current log file
tail_log() {
    local log_file
    log_file=$(get_current_log_file)
    
    if [[ -z "$log_file" ]]; then
        print_error "No active logging session found"
        return 1
    fi
    
    if [[ ! -f "$log_file" ]]; then
        print_error "Log file not found: $log_file"
        return 1
    fi
    
    print_info "Tailing log file: $log_file"
    print_info "Press Ctrl+C to stop"
    tail -f "$log_file"
}

# List all previous logging sessions
list_sessions() {
    if [[ ! -d "$LOG_DIR" ]]; then
        print_error "Log directory not found: $LOG_DIR"
        print_info "No logging sessions have been created yet"
        return 1
    fi
    
    print_info "Previous logging sessions:"
    echo
    
    local count=0
    for log_file in "$LOG_DIR"/history_plus_*.log; do
        [[ ! -f "$log_file" ]] && continue
        count=$((count + 1))
        
        local file_size start_time
        file_size=$(du -h "$log_file" 2>/dev/null | cut -f1 || echo "?")
        start_time=$(head -1 "$log_file" 2>/dev/null | grep "session started at" | sed 's/.*started at //' | sed 's/ ===//' || echo "unknown")
        
        echo "$count. $(basename "$log_file")"
        echo "   Started: $start_time"
        echo "   Size: $file_size"
        echo "   Path: $log_file"
        echo
    done
    
    if [[ $count -eq 0 ]]; then
        print_info "No log files found in $LOG_DIR"
        echo "Use '$SCRIPT_NAME start' to create your first session"
    else
        echo "Use '$SCRIPT_NAME tail' to view the active session log"
        echo "Use 'less <log-file-path>' to view any specific session log"
    fi
}

# Main function
main() {
    case "${1:-}" in
        start)
            start_session
            ;;
        stop)
            stop_session
            ;;
        status)
            show_status
            ;;
        tail)
            tail_log
            ;;
        list)
            list_sessions
            ;;
        help|--help|-h)
            show_usage
            ;;
        "")
            print_error "No command specified"
            echo
            show_usage
            exit 1
            ;;
        *)
            print_error "Unknown command: $1"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
